<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="我最近想要这样一个分享平台：它既可以作为我的笔记工具，记录一些文字不太多又不太少的技术知识，又可以作为一个社交平台让别人认识我，让我可以装逼。微博限制字数，朋友圈也不太合适，于是我还是在博客里开一个以后可能会继续更新的文章。现在 I++ 里的博文只有我在做 C++ 的分享，以后如果有人做同样的事情，甚至写了同名的文章，那就可能要给这整个博客做点修改了，比如在博客的 timeline 上加上作者头像">
<meta property="og:type" content="article">
<meta property="og:title" content="我对C++的编程思考">
<meta property="og:url" content="http://yoursite.com/2015/12/23/我对C-的编程思考/index.html">
<meta property="og:site_name" content="I++ 俱乐部官方博客">
<meta property="og:description" content="我最近想要这样一个分享平台：它既可以作为我的笔记工具，记录一些文字不太多又不太少的技术知识，又可以作为一个社交平台让别人认识我，让我可以装逼。微博限制字数，朋友圈也不太合适，于是我还是在博客里开一个以后可能会继续更新的文章。现在 I++ 里的博文只有我在做 C++ 的分享，以后如果有人做同样的事情，甚至写了同名的文章，那就可能要给这整个博客做点修改了，比如在博客的 timeline 上加上作者头像">
<meta property="og:updated_time" content="2016-07-02T17:55:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我对C++的编程思考">
<meta name="twitter:description" content="我最近想要这样一个分享平台：它既可以作为我的笔记工具，记录一些文字不太多又不太少的技术知识，又可以作为一个社交平台让别人认识我，让我可以装逼。微博限制字数，朋友圈也不太合适，于是我还是在博客里开一个以后可能会继续更新的文章。现在 I++ 里的博文只有我在做 C++ 的分享，以后如果有人做同样的事情，甚至写了同名的文章，那就可能要给这整个博客做点修改了，比如在博客的 timeline 上加上作者头像">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2015/12/23/我对C-的编程思考/"/>

  <title> 我对C++的编程思考 | I++ 俱乐部官方博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">I++ 俱乐部官方博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Here We Code</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                我对C++的编程思考
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-23T21:38:41+08:00" content="2015-12-23">
              2015-12-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我最近想要这样一个分享平台：它既可以作为我的笔记工具，记录一些文字不太多又不太少的技术知识，又可以作为一个社交平台让别人认识我，让我可以装逼。微博限制字数，朋友圈也不太合适，于是我还是在博客里开一个以后可能会继续更新的文章。现在 I++ 里的博文只有我在做 C++ 的分享，以后如果有人做同样的事情，甚至写了同名的文章，那就可能要给这整个博客做点修改了，比如在博客的 timeline 上加上作者头像和信息，以前一直想做，因为比较懒所以搁置了。</p>
<h3 id="应该使用-Returned-Value-Optimization-还是-std-move"><a href="#应该使用-Returned-Value-Optimization-还是-std-move" class="headerlink" title="应该使用 Returned Value Optimization 还是 std::move"></a>应该使用 Returned Value Optimization 还是 <code>std::move</code></h3><hr>
<p>分享一篇我读过的文章 <a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=zh" target="_blank" rel="external">RVO V.S. std::move</a></p>
<p>这里讲到了几个以前我未曾求解的顾虑和疑惑：</p>
<ul>
<li><p>C++11 其实已经将 RVO 写在标准中并为大多数编译器支持。这样编写合适的代码就不会再有顾虑了。</p>
</li>
<li><p>std::move 的使用场景。实际上 std::move 还是会造成一定的开销，只是相比于复制，移动会更快。</p>
</li>
</ul>
<h3 id="C-使用指针还是创建对象？"><a href="#C-使用指针还是创建对象？" class="headerlink" title="C++ 使用指针还是创建对象？"></a>C++ 使用指针还是创建对象？</h3><hr>
<p>阅读这篇文章：<a href="http://blog.jobbole.com/90147/" target="_blank" rel="external">C++中为什么要用指针，而不直接使用对象？</a></p>
<p>最近写一些代码的时候，仅仅只是因为写的顺了，没经过思考地使用了 <code>std::unique_ptr</code>，现在觉得有些后悔，因为这些地方完全可以用对象代替。但是因为除了代码稍微混乱一些之外，并无伤大雅，所以还在犹豫是否要对他们进行修改。以我现在比较浅薄的经验看来，指针能够让我感觉自然的使用场景大概有这些：</p>
<ul>
<li>延迟分配内存（动态分配内存）</li>
</ul>
<p>简单的情况是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object  arr[100];</div><div class="line">Object* arr[100];</div></pre></td></tr></table></figure></p>
<p>对比于上下两种情况，后者在数组初始化的时候开销更小，在有些时候是更好的做法。</p>
<ul>
<li>用于 forward declaration</li>
</ul>
<p>因为 C++ 要求声明对象必须要有类的定义，这就要求必须要 include 相关头文件，为了减少头文件依赖，有时候会用到指针。这种情况也不多。</p>
<ul>
<li>shared_ptr</li>
</ul>
<p>针对某一内存块会被多个使用者同时使用的情况。</p>
<ul>
<li>用于保留容器元素的继承属性</li>
</ul>
<p>假如有 <code>B: public A</code> 与集合 <code>std::set&lt;A&gt;</code>。现在我们需要把 B 放入 A 的集合中，在 Java 中，集合内存储的元素依然是 B，而在 C++ 中，编译器会将 B 复制给类型为 A 的集合元素。此时集合内实际存储的是 A。我们希望实现 Java 的效果，就要使用指针。显然 <code>std::unique_ptr</code> 在这里可以发挥作用。</p>
<p>讲到这里，我想谈一谈我最近遇到的关于 <code>std::unique_ptr</code> 的几个小经历。</p>
<p>###有关 <code>std::unique_ptr</code> 的编程经历</p>
<hr>
<p>语法多如 C++ 的语言总有很多隐形的坑，在编写代码的过程中有时会陷入困境，不知道如何解决，但是山重水复之后，往往会发现柳暗花明的方法。</p>
<ul>
<li>在 stl 容器中存储 unique_ptr</li>
</ul>
<p>我们以 <code>std::set</code> 来举例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> T,                        <span class="comment">// set::key_type/value_type</span></div><div class="line">           <span class="keyword">class</span> Compare = less&lt;T&gt;,        <span class="comment">// set::key_compare/value_compare</span></div><div class="line">           <span class="keyword">class</span> Alloc = allocator&lt;T&gt;      <span class="comment">// set::allocator_type</span></div><div class="line">           &gt; <span class="keyword">class</span> <span class="built_in">set</span>;</div></pre></td></tr></table></figure>
<p>这个接口告诉我们，用户需要在 <code>std::set</code> 声明处定义比较函数 comparator。换句话说，一个 <code>std::set</code> 由两个东西定义，一个是元素类型，一个是元素之间比较的方法（不考虑 allocator）。</p>
<p>我们其实可以将 comparator 从 set 的定义中解耦出来。实际上 C++ 有多种实现自定义比较的方法。如这篇文章所讲 <a href="http://fusharblog.com/3-ways-to-define-comparison-functions-in-cpp/" target="_blank" rel="external">3 Ways to Define Comparison Functions in C++</a>。简单说就是通过重载 <code>operator&lt;</code> 来自定义比较方法，这样做就<strong>无需显式定义 comparator</strong>。当然，更多的时候，我还是喜欢显式定义 comparator，这样能更清楚的表明，<strong>一个 set 只允许一种comparator</strong>。</p>
<p>然而，这与 Java 不同。Java 的模板类型会<a href="http://www.infoq.com/cn/articles/cf-java-generics" target="_blank" rel="external">在运行时用具体的类型代替</a>。也就是说，给定集合 <code>set&lt;T&gt;</code> 可以代表的不只是 T 的集合，也可以是 T 的子类 SubT1 的集合，SubT2 的集合等等，并且他们之间也互相 compatible（可以直接用等号赋值）。这对面向对象来说是十分自然的一种设计，这意味着当我们将 SubT 继承自 T 之后，我们也同时将 SubT 的 container 继承自 T 的 container。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example Code</span></div><div class="line">TreeSet&lt;E&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;E&gt;();</div><div class="line">SubE se = <span class="keyword">new</span> SubE(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">treeSet.add(se);</div><div class="line"><span class="comment">// E 的 print 会输出 E</span></div><div class="line"><span class="comment">// SubE 的 print 会输出 SubE</span></div><div class="line"><span class="comment">// 这里输出的是 SubE</span></div><div class="line">treeSet.first().print();</div></pre></td></tr></table></figure>
<p>而在 C++ 中，我们却需要显式地声明 <code>set&lt;T&gt;</code> 和 <code>set&lt;SubT1&gt;</code>, <code>set&lt;SubT2&gt;</code> … 遇到这个问题，我们可能会开始想到使用 <code>dynamic_cast</code>，然后随即又被<a href="https://www.zhihu.com/question/22445339" target="_blank" rel="external">它的低效率</a>（见 effective c++ 中的条款27）给吓跑。如果我们想要避免 <code>dynamic_cast</code>，本质上，我们就需要一些 workaround <strong>避免 <code>dynamic_cast</code></strong>。</p>
<p>整理一下思路，我们希望能在 <code>std::set</code> 中实现多态（Polymorphism），这其中的核心问题在于实现多态的 comparator。而我们又不希望通过 RTTI 实现 downcast(dynamic_cast)，这意味着，我们<strong>不能直接使用子类 SubT 进行自定义比较</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Example Code</span></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;i1,</div><div class="line">					  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;i2) &#123;</div><div class="line">	<span class="keyword">return</span> i1-&gt;a &lt; i2-&gt;a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; &gt; ASet;</div></pre></td></tr></table></figure>
<p>上面的代码中，在 <code>ASet</code> 中插入 B 的指针时，不会对属性 <code>b</code> 的值进行比较。简单说，相同 <code>a</code> 值，不同 <code>b</code> 值的 B 会被视作相同。</p>
<p>排除了几种选择之后，我们可以想到用 virtual function，利用指针保留继承链。最终我使用的方法是<strong><em>留后门</em></strong>：既然不能直接比较 <code>b</code> 的值，就只能绕弯路，<strong>间接地进行比较</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">virtual</span> boost::<span class="function">any <span class="title">Others</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CompareOthers</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">virtual</span> boost::<span class="function">any <span class="title">Others</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> b;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CompareOthers</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> b &lt; boost::any_cast&lt;<span class="keyword">int</span>&gt;(rhs.Others());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里就可以看到我们留后门的两个函数 <code>Others</code> 和 <code>CompareOthers</code>，间接地利用类型转换来实现。最终的自定义比较函数就可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;i1,</div><div class="line">					  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;i2) &#123;</div><div class="line">	<span class="keyword">if</span>(i1-&gt;a == i2-&gt;a) &#123;</div><div class="line">		<span class="keyword">return</span> i1-&gt;CompareOthers(*i2);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> i1-&gt;a &lt; i2-&gt;a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们算是基本完成了需求的实现。</p>
<p>还有一点。上面我们使用了 <code>boost::any</code> 表示可以接受任何值。这样写比较直观，但是<a href="http://www.nullptr.me/2011/05/10/boostany/" target="_blank" rel="external"><code>any_cast</code> 的实际性能上貌似与 <code>dynamic_cast</code> 相差不大</a>，都是使用 RTTI。在 benchmark 下，甚至可能出现 <a href="https://felipedelamuerte.wordpress.com/2012/04/06/why-you-shouldnt-use-boostany-especially-not-in-time-critical-code/" target="_blank" rel="external"><code>boost::any</code> 比 <code>void *</code> 性能相差近50倍的情况</a>。不过这里有充足的优化空间，我们可以完全不必使用 <code>boost::any_cast</code>，而是简单使用 <code>static_cast</code> 就可完成任务。所以这个方法可行。</p>
<p>看上去，我们好像漂亮地完成了一个（可以不使用 RTTI 的）<a href="https://en.wikipedia.org/wiki/Type_erasure" target="_blank" rel="external"><strong><em>Type Erasure</em></strong></a>。然而，这意味着我们依然需要使用 downcast 来实现 <strong><em>Type inference</em></strong>，否则，我们的子类 SubT 将无法在任何使用了 <code>std::set&lt;std::unique_ptr&lt;T&gt; &gt;</code> 的地方使用。除非我们可以将 T 与其子类完全地从它们的 caller 中解耦出来，这种方案才有意义。换句话说，我们需要让 caller 完全不必在乎它们使用的类型是 T，还是 SubT1，SubT2，所有的细节都由虚函数来完成。如果可以做到这样，我们就能在不使用 RTTI 的情况下，像 Java 那样完成工作。</p>
<p>当然，如果使用了 RTTI，那 C++ 和 Java 的区别就很小了。</p>
<p>多数情况下，我们没有办法不使用 downcast。那么现在问题的核心在于，有没有其他的方法，可以在不使用 RTTI 的前提下，实现 downcast。</p>
<p>如果在对象较小的情况下，我们可以使用 <a href="http://www.cplusplus.com/forum/articles/18757/" target="_blank" rel="external"><strong><em>the clone pattern</em></strong></a> 来实现，但在这里不是 clone，我们定义一个 DownCast 函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">typename std::enable_if&lt;std::is_same&lt;T, B&gt;::value, B&gt;::type</div><div class="line">DownCast(const std::unique_ptr&lt;A&gt; &amp;pA) &#123;</div><div class="line">  B ret(pA-&gt;a, boost::any_cast&lt;int&gt;(pA-&gt;Others()));</div><div class="line">  return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 我们在这里利用复制来进行 downcast，不使用 RTTI</div><div class="line">B b = DownCast&lt;B&gt;(pA);</div></pre></td></tr></table></figure>
<p>当然，我们这里依然假设 <code>boost::any_cast</code> 是一个 exception safe 且 without RTTI 的转换函数。因为我们在这里完全可以优化到这样。</p>
<p>顺便扔出一个刚刚学会的名词：<a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error" target="_blank" rel="external">SFINAE</a></p>
<hr>
<h3 id="更新一下"><a href="#更新一下" class="headerlink" title="更新一下"></a>更新一下</h3><p>之前在 <a href="https://felipedelamuerte.wordpress.com/2012/04/06/why-you-shouldnt-use-boostany-especially-not-in-time-critical-code/" target="_blank" rel="external"><code>boost::any</code> 比 <code>void *</code> 性能相差近50倍</a><br>的链接里，博主提供了测试代码。测试程序测试对基本类型<code>size_t</code>转换所用时长。</p>
<p>benchmark的结果和我的差不太多。<br>在我的 MacBook Air (13-inch, Early 2014)，clang version 3.6.2 下</p>
<p>debug mode 的数据是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boost::any - 18.8269</div><div class="line">boost::spirit::hold_any - 3.50993</div><div class="line">void ptr - 0.860663</div></pre></td></tr></table></figure></p>
<p>release mode 的数据是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boost::any - 8.41195</div><div class="line">boost::spirit::hold_any - 0.499917</div><div class="line">void ptr - 0.043697</div></pre></td></tr></table></figure></p>
<p>公有变量 x 也用了 <code>volatile</code> 修饰，结果应该可靠，可见，<code>boost::any</code> 确实较慢。拖累性能的地方在于exception，可能还因为一部分中间的执行代码，但应该与代码中极少数使用 <code>typeid</code> 的地方无关，知乎上 R大 也曾经解释过，<a href="https://www.zhihu.com/question/38997922/answer/79179526" target="_blank" rel="external">而当typeid运算符应用在一个指向多态类型对象的指针上的时候，typeid的实现才需要有运行时行为。</a></p>
<p>所以我们在上面实现 CompareOthers 和 DownCast 的时候，完全可以不用考虑异常，类型转换失败则程序应停止运行而不是抛出异常。</p>
<hr>
<p>###C++ 中指针的不便之处</p>
<p>跑题了很多，将这次的经历归纳在 <code>std::unique_ptr</code> 下更多的是因为，C++ 中指针与对象之间被区分开，这就意味着，<br>我们在判断两个 <code>std::set&lt;std::unique_ptr&lt;A&gt; &gt;</code> 是否相同时，默认对指针进行比较，而不是对对象进行比较。<br>这个时候，我们要为此编写 <code>std::set</code> 的自定义比较函数。</p>
<p>我们在使用 <code>std::unordered_set&lt;std::unique_ptr&lt;A&gt; &gt;</code> 时也会有相同的问题，同样的，我们也要编写自定义 hasher。</p>
<p>如果这被 C++ 标准认为是自然的行为的话，那么，我们来看看它会带来的不便之处。</p>
<p>不便之处在我们使用 <code>std::set&lt;std::set&lt;std::unique_ptr&gt; &gt;</code> 时尤为突出。虽然 <code>unique_ptr</code> 禁止 copy，但是 set<br>是允许 copy 的，这就意味这我们可能需要重新编写 set<unique_ptr> 的复制函数。这让我很疑惑为什么 unique_ptr<br>没有提供默认的 deep copy 接口来复制所指的对象。</unique_ptr></p>
<p>我们为了使用 <code>std::set&lt;std::unique_ptr&gt;</code>，编写了custom comparator。在使用 <code>std::set&lt;std::set&lt;std::unique_ptr&gt; &gt;</code> 时，我们无需再次编写 comparator（stl 为提供 <code>std::set</code> 了 rational operator）。然而，如果我们使用的是 <code>std::unordered_set&lt;std::set&lt;std::unique_ptr&lt;A&gt; &gt; &gt;</code>，我们可能会这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> AHasher &#123;</div><div class="line">  <span class="keyword">size_t</span></div><div class="line">  <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;val) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> boost::hash_value(val);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里使用了 <code>boost/functional/hash.hpp</code>。这里看起来合理，但程序运行的时候，我们会发现这与我们预期的不符。这是因为，我们忽略了为 <code>std::unique_ptr&lt;A&gt;</code> 自定义 hasher。这里默认地是对指针的值进行 hash，而不是对对象进行 hash。</p>
<p>重写一下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> AHasher &#123;</div><div class="line">  <span class="keyword">size_t</span></div><div class="line">  <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;val) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> seed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;it : val) &#123;</div><div class="line">      boost::hash_combine(seed, it-&gt;HashValue());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> seed;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>原来我们在 set 中存储本来的对象，只需要定义好对象本身的 rational operator 和 copy function，亦或者是 <code>unordered_set</code><br>中的 hasher，就可以很自然地使用了。使用了 <code>unique_ptr</code> 之后，我们还需要重新定义 unique_ptr 的对应函数，才能将 <code>unique_ptr</code> 完全视作对象。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag">#C++</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/11/05/React-Native-下一代UI开发思维/" rel="next" title="React-Native -- 下一代UI开发思维">
                <i class="fa fa-chevron-left"></i> React-Native -- 下一代UI开发思维
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/12/26/Swift之AnyClass与动态类型/" rel="prev" title="Swift之AnyClass与动态类型">
                Swift之AnyClass与动态类型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/ippclub.jpg"
               alt="I++ 俱乐部" />
          <p class="site-author-name" itemprop="name">I++ 俱乐部</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#应该使用-Returned-Value-Optimization-还是-std-move"><span class="nav-number">1.</span> <span class="nav-text">应该使用 Returned Value Optimization 还是 std::move</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-使用指针还是创建对象？"><span class="nav-number">2.</span> <span class="nav-text">C++ 使用指针还是创建对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新一下"><span class="nav-number">3.</span> <span class="nav-text">更新一下</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">I++ 俱乐部</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

</body>
</html>
